import { r as __toESM, t as require_react } from "./react-CRcsxt9d.js";
import { A as classNames, D as ObjectUtils, c as useMergeProps, n as useHandleStyle, t as ComponentBase, w as DomHandler, x as PrimeReactContext } from "./componentbase.esm-BaFTkeT7.js";
import { t as Tooltip } from "./tooltip.esm-BhErihQm.js";

//#region node_modules/primereact/keyfilter/keyfilter.esm.js
function _arrayLikeToArray(r, a) {
	(null == a || a > r.length) && (a = r.length);
	for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
	return n;
}
function _arrayWithoutHoles(r) {
	if (Array.isArray(r)) return _arrayLikeToArray(r);
}
function _iterableToArray(r) {
	if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
function _unsupportedIterableToArray(r, a) {
	if (r) {
		if ("string" == typeof r) return _arrayLikeToArray(r, a);
		var t = {}.toString.call(r).slice(8, -1);
		return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
	}
}
function _nonIterableSpread() {
	throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toConsumableArray(r) {
	return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();
}
var KeyFilter = {
	DEFAULT_MASKS: {
		pint: /[\d]/,
		"int": /[\d\-]/,
		pnum: /[\d\.]/,
		money: /[\d\.\s,]/,
		num: /[\d\-\.]/,
		hex: /[0-9a-f]/i,
		email: /[a-z0-9_\.\-@]/i,
		alpha: /[a-z_]/i,
		alphanum: /[a-z0-9_]/i
	},
	getRegex: function getRegex(keyfilter) {
		return KeyFilter.DEFAULT_MASKS[keyfilter] ? KeyFilter.DEFAULT_MASKS[keyfilter] : keyfilter;
	},
	onBeforeInput: function onBeforeInput(e, keyfilter, validateOnly) {
		if (validateOnly || !DomHandler.isAndroid()) return;
		this.validateKey(e, e.data, keyfilter);
	},
	onKeyPress: function onKeyPress(e, keyfilter, validateOnly) {
		if (validateOnly || DomHandler.isAndroid()) return;
		if (e.ctrlKey || e.altKey || e.metaKey) return;
		this.validateKey(e, e.key, keyfilter);
	},
	onPaste: function onPaste(e, keyfilter, validateOnly) {
		if (validateOnly) return;
		var regex = this.getRegex(keyfilter);
		_toConsumableArray(e.clipboardData.getData("text")).forEach(function(c) {
			if (!regex.test(c)) {
				e.preventDefault();
				return false;
			}
		});
	},
	validateKey: function validateKey(e, key, keyfilter) {
		if (key === null || key === void 0) return;
		if (!(key.length <= 2)) return;
		if (!this.getRegex(keyfilter).test(key)) e.preventDefault();
	},
	validate: function validate(e, keyfilter) {
		var value = e.target.value;
		var validatePattern = true;
		var regex = this.getRegex(keyfilter);
		if (value && !regex.test(value)) validatePattern = false;
		return validatePattern;
	}
};

//#endregion
//#region node_modules/primereact/inputtext/inputtext.esm.js
var import_react = /* @__PURE__ */ __toESM(require_react());
function _extends() {
	return _extends = Object.assign ? Object.assign.bind() : function(n) {
		for (var e = 1; e < arguments.length; e++) {
			var t = arguments[e];
			for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
		}
		return n;
	}, _extends.apply(null, arguments);
}
function _typeof(o) {
	"@babel/helpers - typeof";
	return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o) {
		return typeof o;
	} : function(o) {
		return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
	}, _typeof(o);
}
function toPrimitive(t, r) {
	if ("object" != _typeof(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r || "default");
		if ("object" != _typeof(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r ? String : Number)(t);
}
function toPropertyKey(t) {
	var i = toPrimitive(t, "string");
	return "symbol" == _typeof(i) ? i : i + "";
}
function _defineProperty(e, r, t) {
	return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
		value: t,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : e[r] = t, e;
}
var InputTextBase = ComponentBase.extend({
	defaultProps: {
		__TYPE: "InputText",
		__parentMetadata: null,
		children: void 0,
		className: null,
		invalid: false,
		variant: null,
		keyfilter: null,
		onBeforeInput: null,
		onInput: null,
		onKeyDown: null,
		onPaste: null,
		tooltip: null,
		tooltipOptions: null,
		validateOnly: false,
		iconPosition: null
	},
	css: { classes: { root: function root(_ref) {
		var props = _ref.props, isFilled = _ref.isFilled, context = _ref.context;
		return classNames("p-inputtext p-component", {
			"p-disabled": props.disabled,
			"p-filled": isFilled,
			"p-invalid": props.invalid,
			"p-variant-filled": props.variant ? props.variant === "filled" : context && context.inputStyle === "filled"
		});
	} } }
});
function ownKeys(e, r) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r && (o = o.filter(function(r) {
			return Object.getOwnPropertyDescriptor(e, r).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread(e) {
	for (var r = 1; r < arguments.length; r++) {
		var t = null != arguments[r] ? arguments[r] : {};
		r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {
			_defineProperty(e, r, t[r]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {
			Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
		});
	}
	return e;
}
var InputText = /* @__PURE__ */ import_react.memo(/* @__PURE__ */ import_react.forwardRef(function(inProps, ref) {
	var mergeProps = useMergeProps();
	var context = import_react.useContext(PrimeReactContext);
	var props = InputTextBase.getProps(inProps, context);
	var _InputTextBase$setMet = InputTextBase.setMetaData(_objectSpread(_objectSpread({ props }, props.__parentMetadata), {}, { context: {
		disabled: props.disabled,
		iconPosition: props.iconPosition
	} })), ptm = _InputTextBase$setMet.ptm, cx = _InputTextBase$setMet.cx, isUnstyled = _InputTextBase$setMet.isUnstyled;
	useHandleStyle(InputTextBase.css.styles, isUnstyled, {
		name: "inputtext",
		styled: true
	});
	var elementRef = import_react.useRef(ref);
	var onKeyDown = function onKeyDown(event) {
		props.onKeyDown && props.onKeyDown(event);
		if (props.keyfilter) KeyFilter.onKeyPress(event, props.keyfilter, props.validateOnly);
	};
	var onBeforeInput = function onBeforeInput(event) {
		props.onBeforeInput && props.onBeforeInput(event);
		if (props.keyfilter) KeyFilter.onBeforeInput(event, props.keyfilter, props.validateOnly);
	};
	var onInput = function onInput(event) {
		var target = event.target;
		var validatePattern = true;
		if (props.keyfilter && props.validateOnly) validatePattern = KeyFilter.validate(event, props.keyfilter);
		props.onInput && props.onInput(event, validatePattern);
		ObjectUtils.isNotEmpty(target.value) ? DomHandler.addClass(target, "p-filled") : DomHandler.removeClass(target, "p-filled");
	};
	var onPaste = function onPaste(event) {
		props.onPaste && props.onPaste(event);
		if (props.keyfilter) KeyFilter.onPaste(event, props.keyfilter, props.validateOnly);
	};
	import_react.useEffect(function() {
		ObjectUtils.combinedRefs(elementRef, ref);
	}, [elementRef, ref]);
	var isFilled = import_react.useMemo(function() {
		return ObjectUtils.isNotEmpty(props.value) || ObjectUtils.isNotEmpty(props.defaultValue);
	}, [props.value, props.defaultValue]);
	var hasTooltip = ObjectUtils.isNotEmpty(props.tooltip);
	import_react.useEffect(function() {
		var _elementRef$current;
		if (isFilled || (_elementRef$current = elementRef.current) !== null && _elementRef$current !== void 0 && _elementRef$current.value) DomHandler.addClass(elementRef.current, "p-filled");
		else DomHandler.removeClass(elementRef.current, "p-filled");
	}, [props.disabled, isFilled]);
	var rootProps = mergeProps({
		className: classNames(props.className, cx("root", {
			context,
			isFilled
		})),
		onBeforeInput,
		onInput,
		onKeyDown,
		onPaste
	}, InputTextBase.getOtherProps(props), ptm("root"));
	return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement("input", _extends({ ref: elementRef }, rootProps)), hasTooltip && /* @__PURE__ */ import_react.createElement(Tooltip, _extends({
		target: elementRef,
		content: props.tooltip,
		pt: ptm("tooltip")
	}, props.tooltipOptions)));
}));
InputText.displayName = "InputText";

//#endregion
export { InputText as t };
//# sourceMappingURL=inputtext.esm-DtqoO4FS.js.map